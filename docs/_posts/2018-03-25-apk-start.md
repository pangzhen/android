---
layout: post
title: "Activity启动app分析"
---

常规的Activity启动app就是从主界面点击应用程序的图标来启动app，这个启动过程分为三个阶段:
1. 主界面的launcher进入stop状态
2. zygote 创建新进程
3. 在新进程中运行app  

以下从这三个阶段分析Activity启动app，使用的Android源码版本是Android 4.4.4_r1 - KitKat。在Android studio中用默认的配置建立一个myapplication的app，用于调试分析。

> 目录
> 
> * auto-gen TOC:
> {:toc}

# [](#header-1)1.进程间关系

从进程的角度去分析这三个阶段，它们是分别运行在不同的进程中，用ps命令可以查看，
>  ps \| grep -E "NAME\|[a-z\\.]launcher\|zygote\|[a-z\\.]myapplication"  

![]({{ site.url }}/android/images/apk-start/3-process.png)

三个进程间是彼此独立的，但要让它们有序的运行就需要一个协调调度的对象，这个对象就是整个java层的总服务system_server进程，在系统的java层正是由于它的勤勤恳恳才能有条不紊的运行下去。它们之间的关系可以用下图简单表示，
![]({{ site.url }}/android/images/apk-start/4-process.png)

* launcher-system_server、myapplication-system_server：launcher和myapplication本质上都是app，只是前者是系统内置的应用，后者是开发者的应用，它们与system_server之间的通信都是依赖系统的Binder机制。
* zygote-system_server：zygote是java层创建进程的惟一一个通道，它有自身的一套通信机制，就是socket，需要创建进程就通过zygote的socket发送请求，zygote收到请求后最终是通过linux内核fork出子进程供使用。

# [](#header-1)2.实现架构
app与system-server之间依赖的Binder通信机制，本质上是C-S架构，从名称和逻辑上也可以看出，system-server是作为Server端，app是Client端，关系如[下图所示]({{ site.url }}/android/images/apk-start/CS.png){:target="_blank"}，

![]({{ site.url }}/android/images/apk-start/CS.png)


先看Server端，
* `ActivityManagerService` ：
1. 继承ActivityManagerNative，并且重载了IActivityManager的方法，从而实现对Activity的管理
2. IActivityManager继承了Binder，所以ActivityManagerService具有进程间通信的能力，其他对象通过getDefault函数获取Binder的本地代理对象，从而向ActivityManagerService发起请求
3. 
* `ProcessRecord`：一个应用进程在Server端的表示，与ActivityThread对应，通过ActivityThread的内部类ApplicationThread绑定




# [](#header-1)3.流程分析


## [](#header-2)3.1 launcher的stop流程

launcher进入stop前需要准备好myapplication的Activity信息，否则launcher进入stop后就没法处理了，所以整个流程被分为4个部分：
1. launcher启动myapplication的Activity
2. ActivityManagerService创建Activity相关信息，ActivityInfo、ActivityRecord、ActivityStack、TaskRecord
3. WindowManagerService设置Activity切换时的显示
4. launcher进入pause、stop

每个部分涉及到主要的类如[下图所示]({{ site.url }}/android/images/apk-start/launcher_stop.png){:target="_blank"}，

![]({{ site.url }}/android/images/apk-start/launcher_stop.png)

主要的函数调用层次如下：
```java
startActivity  //在主界面点击myapplication                       //Activity.java
↓
startActivityForResult 
  ↓
  execStartActivity                                            //Instrumentation.java
    ↓
    startActivity                                              //ActivityManagerService.java
    ↓           
    startActivityAsUser
      ↓
      startActivityMayWait //创建ActivityInfo                  //ActivityStackSupervisor.java
      ↓
      startActivityLocked //创建ActivityRecord
      ↓
      startActivityUncheckedLocked //创建ActivityStack、TaskRecord
        ↓
        startActivityLocked //WindowManagerService设置Activity切换      //ActivityStack.java
          ↓
          resumeTopActivitiesLocked //参数都为null，其实是pause launcher //ActivityStackSupervisor.java
            ↓
            resumeTopActivityLocked                                    //ActivityStack.java
              ↓
              pauseBackStacks                                          //ActivityStackSupervisor.java
                ↓
                startPausingLocked                                     //ActivityStack.java
                  ↓
                  handlePauseActivity //调用Activity生命周期函数        //ActivityThread.java
                    ↓
                    activityPaused                                    //ActivityManagerService.java
                      ↓
                      activityPausedLocked                              //ActivityStack.java
                      ↓
                      completePauseLocked
                        ↓
                        scheduleIdleLocked                             //ActivityStackSupervisor.java
                          ↓
                          stopActivityLocked                            //ActivityStack.java
                            ↓
                            handleStopActivity //调用Activity生命周期函数  //ActivityThread.java
                        ↓
                        resumeTopActivitiesLocked                        //ActivityStackSupervisor.java
                          ↓
                          resumeTopActivityLocked//WMS处理Activity切换显示  //ActivityStack.java

```
完整的时序图如[下图所示]({{ site.url }}/android/images/apk-start/PauseActivity.png){:target="_blank"}，

![]({{ site.url }}/android/images/apk-start/PauseActivity.png)


## [](#header-2)3.2 zygote的fork流程

分为两部分，  
1. 是ActivityManagerService创建ProcessRecord对象，表示一个新进程用于即将启动的app，然后通过socket向zygote进程发请求
2. 是zygote进程接收到数据再fork出子进程，然后调起ActivityThread的main函数，从而启动app的进程

每个部分涉及到主要的类如[下图所示]({{ site.url }}/android/images/apk-start/zygote-fork.png){:target="_blank"}，

![]({{ site.url }}/android/images/apk-start/zygote-fork.png)

```java
resumeTopActivityLocked//WMS处理Activity切换显示                     //ActivityStack.java
  ↓
  startSpecificActivityLocked                                       //ActivityStackSupervisor.java
    ↓
    startProcessLocked  //创建ProcessRecord                         //ActivityManagerService.java
      ↓
      start                                                         //Process.java
        ↓
        startViaZygote
          ↓
          zygoteSendArgsAndGetResult //发送数据

runSelectLoop //zygote进程在loop中等待接收数据                         //ZygoteInit.java
  ↓
  runOnce //接收到数据
    ↓
    forkAndSpecialize //Linux内核创建出新进程
    ↓
    handleChildProc 
      ↓
      invokeStaticMain //调用ActivityThread的main函数
```
完整的时序图如[下图所示]({{ site.url }}/android/images/apk-start/zygote.png){:target="_blank"}，

![]({{ site.url }}/android/images/apk-start/zygote.png)

## [](#header-2)3.3 myapplication的启动流程

分为三部分，  
1. 在ActivityManagerService中，把ProcessRecord与ActivityThrea关联起来
2. 在ActivityThread中，创建一系列与app进程相关的对象
3. 也是在ActivityThread中，创建ActivityClientRecord以及Activity，调度Activity生命周期

每个部分涉及到主要的类如[下图所示]({{ site.url }}/android/images/apk-start/start-activity.png){:target="_blank"}，

![]({{ site.url }}/android/images/apk-start/start-activity.png)

```java
main                                                                //ActivityThread.java
  ↓
  attach
    ↓
    attachApplication                                               //ActivityManagerService.java
      ↓
      attachApplicationLocked
        ↓
        makeActive //ProcessRecord与ActivityThread关联               //ProcessRecord.java
        ↓
        bindApplication                                             //ActivityThread.java
          ↓
          handleBindApplication
            ↓
            getPackageInfoNoCheck //创建LoadedApk对象
            ↓
            Instrumentation //创建Instrumentation对象
            ↓
            makeApplication                                                  //LoadedApk.java
              ↓
              createAppContext //创建ContextImpl对象                          //ContextImpl.java
              ↓
              newApplication //创建Application对象                            //Instrumentation.java
            ↓
            callApplicationOnCreate 
        ↓
        attachApplicationLocked                                        //ActivityStackSupervisor.java
          ↓
          realStartActivityLocked
            ↓
            scheduleLaunchActivity //创建ActivityClientRecord对象              //ActivityThread.java
              ↓
              handleLaunchActivity 
                ↓
                performLaunchActivity
                  ↓
                  newActivity //创建Activity对象                               //Instrumentation.java
                  ↓               
                  createBaseContextForActivity //创建Activity的Context对象     //ContextImpl.java
                  ↓
                  attach                                                      //Activity.java
                  ↓
                  callActivityOnCreate //调用Activity生命周期函数               //Instrumentation.java
                  ↓
                  performStart //调用Activity生命周期函数                       //Activity.java
                ↓
                handleResumeActivity //WMS控制Activity显示                     //ActivityThread.java
                  ↓
                  performResumeActivity //调用Activity生命周期函数              //Activity.java
```
完整的时序图如[下图所示]({{ site.url }}/android/images/apk-start/StartActivityUML.png){:target="_blank"}，

![]({{ site.url }}/android/images/apk-start/StartActivityUML.png)
 



# [](#header-1)4.源码分析

## [](#header-2)4.1 launcher的stop过程源码分析

在Activity.java找到startActivity方法，打断点然后点击myapplication图标启动app，查看函数调用栈，如[下图所示]({{ site.url }}/android/images/apk-start/start_activity.png){:target="_blank"}，

![]({{ site.url }}/android/images/apk-start/start_activity.png)

从函数调用栈可以看出，主界面就是launcher2,往下看发现launcher2是从ActivityThread的main函数开始的，显然它也是一个app。  
最下面是dalvik虚拟机，然后是ZygoteInit的main函数，接着是捕获异常里面调用的run函数，这些都是前面分析zygote提过的，这也说明android系统给每个app都分配了一个独立的进程，只是入口函数main被埋藏得比较深。  
android系统通过四大组件把进程的概念掩盖掉了，深入去了解android系统就会发现进程间的通信无处不在，binder机制是系统实现进程间通信的基石。

传入的参数如下，intent跟平常app启动Activity传入的参数一样，没有什么特别。
* `Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.demo.myapplication/.MainActivity bnds=[80,143][160,243] }`
* `Bundle[{android:animStartX=80, android:animStartY=143, android:animType=2, android:animStartWidth=80, android:packageName=com.android.launcher, android:animStartHeight=100}]`

```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/Activity.java
    public void startActivity(Intent intent, Bundle options) {
        if (options != null) {
            startActivityForResult(intent, -1, options);
        } else {
            // Note we want to go through this call for compatibility with
            // applications that may have overridden the method.
            startActivityForResult(intent, -1);
        }
    }

    public void startActivityForResult(Intent intent, int requestCode, Bundle options) {
        //mParent是多个Activity嵌入组成TabActivity时的根Activity，这种机制已经被Fragment替代，所以被废弃掉。
        //mParent始终是为null
        if (mParent == null) {
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
            if (ar != null) {
                mMainThread.sendActivityResult(
                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                    ar.getResultData());
            }

            .....//省略其他代码
        } 

        .....//省略其他代码

    }
```
* `mMainThread`launcher的ActivityThread对象，虽然名字里面有Thread，但它不是一个线程，
是管理app进程中主线程的事务。  
* `getApplicationThread()`是返回launcher的ApplicationThread对象，同样这个对象也不是一个线程，而且还是ActivityThread的一个内部类，是ActivityManagerService调度ActivityThread的接口，ActivityManagerService是在system_server进程中，应用程序又是一个独立的进程，两个进程间的通信自然少不了Binder，ApplicationThread正是继承了Binder。

![]({{ site.url }}/android/images/apk-start/ApplicationThread.png)

* `mToken` 是进程间通信中传递对象的标识，具体来说是ActivityRecord类的内部类Token，
Token继承了IApplicationToken.Stub，是Binder类型的对象。


```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/Instrumentation.java
    public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
	
	IApplicationThread whoThread = (IApplicationThread) contextThread;

 .....//省略其他代码

        try {
            //对intent的处理
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();

            //进入ActivityManagerService所在的system_server进程
            int result = ActivityManagerNative.getDefault()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, null, options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
        }
        return null;
    }
```
* `whoThread`：是launcher的IApplicationThread接口对象。  
* `getDefault()`：返回ActivityManagerService在本地进程的代理对象，通过binder通信，
最终会调用到在system_server进程中的ActivityManagerService。  
代理对象的transact函数中flag为0，表示是阻塞调用，也就是要等到startActivity执行完后才继续往下走。
   

进入到system_server进程中的ActivityManagerService
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
    public final int startActivity(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo,
            String resultWho, int requestCode, int startFlags,
            String profileFile, ParcelFileDescriptor profileFd, Bundle options) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode,
                startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());
    }
```
传入的参数如[下图]({{ site.url }}/android/images/apk-start/startActivity.png){:target="_blank"}所示，
* `caller`是ApplicationThreadProxy，是在launcer在远端的代理对象，此时ActivityManagerService持有代理对象作为客户端，launch进程是服务端。
* `resultTo`是指向launch的，即是启动返回给哪个对象。
![]({{ site.url }}/android/images/apk-start/startActivity.png)

```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo,
            String resultWho, int requestCode, int startFlags,
            String profileFile, ParcelFileDescriptor profileFd, Bundle options, int userId) {

        .....//省略其他代码

        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType,
                resultTo, resultWho, requestCode, startFlags, profileFile, profileFd,
                null, null, options, userId);
    }
```

`startActivityMayWait`函数中使用了synchronized同步锁去控制启动Activity，如果用am类的命令启动Activity可以阻塞等待到Activity启动完成，所以函数名有MayWait
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
    final int startActivityMayWait(IApplicationThread caller, int callingUid,
            String callingPackage, Intent intent, String resolvedType, IBinder resultTo,
            String resultWho, int requestCode, int startFlags, String profileFile,
            ParcelFileDescriptor profileFd, WaitResult outResult, Configuration config,
            Bundle options, int userId) {

	   .....//省略其他代码

        //通过PackagedManagerService解析将要启动的Activity包信息
        ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags,
                profileFile, profileFd, userId);

        //mService是ActivityManagerService
        synchronized (mService) {

            int res = startActivityLocked(caller, intent, resolvedType,
                    aInfo, resultTo, resultWho, requestCode, callingPid, callingUid,
                    callingPackage, startFlags, options, componentSpecified, null);

	   .....//省略其他代码

            return res;
        }
    }

    //startActivityLocked函数很长，
    //主要是创建要启动的Activity的ActivityRecord对象。
    final int startActivityLocked(IApplicationThread caller,
            Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo,
            String resultWho, int requestCode,
            int callingPid, int callingUid, String callingPackage, int startFlags, Bundle options,
            boolean componentSpecified, ActivityRecord[] outActivity) {
        int err = ActivityManager.START_SUCCESS;

        ProcessRecord callerApp = null;
        if (caller != null) {
            //在ActivityManagerService的成员变量mLruProcesses中取出
            //当出现Activity切换的时候，调用updateLruProcessLocked函数更新mLruProcesses
            callerApp = mService.getRecordForAppLocked(caller);
							       
	       .....//省略其他代码

        }

	   .....//省略其他代码

        //ActivityRecord是ActivityManagerService中用来记录Activity对象，
        //通过内部类Token（Binder类型）与app应用中的ActivityClientRecord对应
        ActivityRecord sourceRecord = null;
        ActivityRecord resultRecord = null;
        if (resultTo != null) {
            //resultTo是ActivityRecord内部类IApplicationToken.Stub
            //在类成员变量ArrayList<ActivityStack> mStacks
            //中根据resultTo查找每个app应用的ActivityStack
            sourceRecord = isInAnyStackLocked(resultTo);
							
            .....//省略其他代码
        }

        .....//省略其他代码

        //检查Intent是否正确
        boolean abort = !mService.mIntentFirewall.checkStartActivity(intent, callingUid,
                callingPid, resolvedType, aInfo.applicationInfo);

	   .....//省略其他代码

        //ActivityRecord记录了Activity的所有信息，
        //其中内部类Token是ActivityRecord在进程间通信的标识

        //在 new ActivityRecord  的参数中，
        // callerApp、callingUid、callingPackage 都是指向launcher的相关信息
        // resolvedType 是null
        // aInfo 指向将要启动的ActivityInfo
        // mService.mConfiguration 系统设置、屏幕分辨率、输入法等配置参数
        // resultRecord是null
        // resultWho是null
        ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,
                intent, resolvedType, aInfo, mService.mConfiguration,
                resultRecord, resultWho, requestCode, componentSpecified, this);
        if (outActivity != null) {
            outActivity[0] = r;
        }

	   .....//省略其他代码

        err = startActivityUncheckedLocked(r, sourceRecord, startFlags, true, options);

	   .....//省略其他代码

        return err;
    }

    //接下来是调用startActivityUncheckedLocked函数，
    //这里是处理activity的LaunchMode、Stack、Task之间的关系，
    //它们之间关系复杂导致函数很长，要是拆分开来实现，分析起来会更顺畅。  
    //这次分析涉及到的主要是创建将要启动的Activity的ActivityStack和TaskRecord，
    //建立ActivityRecord和ActivityStack、TaskRecord之间的关系
    //省略掉没有调用到的代码。
    final int startActivityUncheckedLocked(ActivityRecord r,
            ActivityRecord sourceRecord, int startFlags, boolean doResume,
            Bundle options) {
        final Intent intent = r.intent;
        final int callingUid = r.launchedFromUid;

        //launchFlags = 0x10200000
        //即是FLAG_ACTIVITY_NEW_TASK || FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
        int launchFlags = intent.getFlags();
                             
        
        // We'll invoke onUserLeaving before onPause only if the launching
        // activity did not explicitly state that this is an automated launcher.
        //mUserLeaving = 1,
        //表示是用户离开launcher，会调用launcher的onUserLeaving函数
        mUserLeaving = (launchFlags&Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;

        .....//省略其他代码

        ActivityInfo newTaskInfo = null;
        Intent newTaskIntent = null;

        .....//省略其他代码

        TaskRecord reuseTask = null;
        ActivityStack targetStack;

        boolean newTask = false;
        boolean keepCurTransition = false;

        // Should this be considered a new task?
        if (r.resultTo == null && !addingToTask
                && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {

            //调用createStack创建ActivityStack对象，并添加到mStacks中
            //把mFocusedStack更新为新创建的ActivityStack对象
            //具体实现在startActivityUncheckedLocked-adjustStackFocus
            targetStack = adjustStackFocus(r);  

            //mStackState置为STACK_STATE_HOME_TO_BACK
            moveHomeStack(targetStack.isHomeStack());

            if (reuseTask == null) {
                //具体分析在startActivityUncheckedLocked-setTask
                //具体分析在startActivityUncheckedLocked-createTaskRecord
                r.setTask(targetStack.createTaskRecord(getNextTaskId(),
                        newTaskInfo != null ? newTaskInfo : r.info,
                        newTaskIntent != null ? newTaskIntent : intent,
                        true), null, true);     
                if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r + " in new task " +
                        r.task);
            } else {
                r.setTask(reuseTask, reuseTask, true);
            }
            newTask = true;


 .....//省略其他代码
        } 

 .....//省略其他代码

        //具体分析在startActivityUncheckedLocked-startActivityLocked
        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);

        //更新了mFocusedActivity和mFocusedStack
        mService.setFocusedActivityLocked(r);
        return ActivityManager.START_SUCCESS;
    }

//向ActivityManagerService请求创建ActivityStack
//startActivityUncheckedLocked-adjustStackFocus：
    ActivityStack adjustStackFocus(ActivityRecord r) {
        final TaskRecord task = r.task;
        if (r.isApplicationActivity() || (task != null && task.isApplicationTask())) {
            .....//省略其他代码
            }

            // Time to create the first app stack for this user.
            int stackId =
                    mService.createStack(-1, HOME_STACK_ID, StackBox.TASK_STACK_GOES_OVER, 1.0f);
            if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG, "adjustStackFocus: New stack r=" + r +
                    " stackId=" + stackId);
            mFocusedStack = getStack(stackId);
            return mFocusedStack;
        }
        return mHomeStack;
    }

//ActivityManagerService交给ActivityStackSupervisor创建ActivityStack
//ActivityStack通过stackId与WindowManagerService关联起来
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
    public int createStack(int taskId, int relativeStackBoxId, int position, float weight) {
        enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,
                "createStack()");
        if (DEBUG_STACK) Slog.d(TAG, "createStack: taskId=" + taskId + " relStackBoxId=" +
                relativeStackBoxId + " position=" + position + " weight=" + weight);
        synchronized (this) {
            long ident = Binder.clearCallingIdentity();
            try {
                int stackId = mStackSupervisor.createStack();
                mWindowManager.createStack(stackId, relativeStackBoxId, position, weight);
                if (taskId > 0) {
                    moveTaskToStack(taskId, stackId, true);
                }
                return stackId;
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
    }
```

startActivityUncheckedLocked-setTask：
ActivityRecord的类成员变量task也持有TaskRecord对象
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityRecord.java
    void setTask(TaskRecord newTask, ThumbnailHolder newThumbHolder, boolean isRoot) {

        .....//省略其他代码

        if (inHistory && !finishing) {
            if (task != null) {
                task.numActivities--;
            }
            if (newTask != null) {
                newTask.numActivities++;
            }
        }

        //task的缩略图
        if (newThumbHolder == null) {
            newThumbHolder = newTask;
        }
        task = newTask;
        if (!isRoot && (intent.getFlags()&Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
            // This is the start of a new sub-task.
            if (thumbHolder == null) {
                thumbHolder = new ThumbnailHolder();
            }
        } else {
            thumbHolder = newThumbHolder;
        }
    }
```

startActivityUncheckedLocked-createTaskRecord：
在ActivityStack中创建了TaskRecord对象，并且保存在mTaskHistory中,
ActivityStack并没有直接和ActivityRecord建立关系，而是通过中间的TaskRecord
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStack.java
    TaskRecord createTaskRecord(int taskId, ActivityInfo info, Intent intent, boolean toTop) {
        TaskRecord task = new TaskRecord(taskId, info, intent);
        addTask(task, toTop);
        return task;
    }
```

startActivityUncheckedLocked-startActivityLocked：
处理完LaunchMode、Stack、Task后，交给WindowManagerService处理，控制Activity切换时候的显示
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStack.java
    final void startActivityLocked(ActivityRecord r, boolean newTask,
            boolean doResume, boolean keepCurTransition, Bundle options) {
        TaskRecord rTask = r.task;
        final int taskId = rTask.taskId;
        if (taskForIdLocked(taskId) == null || newTask) {	
            //把要启动的Activity的Task移到顶层
            // Last activity in task had been removed or ActivityManagerService is reusing task.
            // Insert or replace.
            // Might not even be in.
            insertTaskAtTop(rTask);
            mWindowManager.moveTaskToTop(taskId);
        }
        TaskRecord task = null;

        .....//省略其他代码

        task = r.task;

        .....//省略其他代码

        task.addActivityToTop(r);
        task.setFrontOfTask();

        r.putInHistory();
        if (!isHomeStack() || numActivities() > 0) {
            // We want to show the starting preview window if we are
            // switching to a new task, or the next activity's process is
            // not currently running.
            boolean showStartingIcon = newTask;
            ProcessRecord proc = r.app;	//proc = null
            if (proc == null) {
                proc = mService.mProcessNames.get(r.processName, r.info.applicationInfo.uid);
            }
            if (proc == null || proc.thread == null) {
                showStartingIcon = true;
            }
            if (DEBUG_TRANSITION) Slog.v(TAG,
                    "Prepare open transition: starting " + r);
            if ((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
                .....//省略其他代码
            } else {
                //设置切换Activity时的动画
                mWindowManager.prepareAppTransition(newTask
                        ? AppTransition.TRANSIT_TASK_OPEN
                        : AppTransition.TRANSIT_ACTIVITY_OPEN, keepCurTransition);
                mNoAnimActivities.remove(r);
            }
            r.updateOptionsLocked(options);

            //r和WindowManagerService绑定，
            //通过r的IApplicationToken即是IBinder做标识
            mWindowManager.addAppToken(task.mActivities.indexOf(r),
                    r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,
                    (r.info.flags & ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0, r.userId,
                    r.info.configChanges);
            boolean doShow = true;
            if (newTask) {
                // Even though this activity is starting fresh, we still need
                // to reset it to make sure we apply affinities to move any
                // existing activities from other tasks in to it.
                // If the caller has requested that the target task be
                // reset, then do so.
                if ((r.intent.getFlags()
                        &Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
                    resetTaskIfNeededLocked(r, r);

                    //顶层的activity就是r，返回true
                    doShow = topRunningNonDelayedActivityLocked(null) == r;
                }
            }
            if (SHOW_APP_STARTING_PREVIEW && doShow) {
                // Figure out if we are transitioning from another activity that is
                // "has the same starting icon" as the next one.  This allows the
                // window manager to keep the previous window it had previously
                // created, if it still had one.
                ActivityRecord prev = mResumedActivity;//prev = null

                .....//省略其他代码

                 //WindowManagerServer相关设置
                mWindowManager.setAppStartingWindow(
                        r.appToken, r.packageName, r.theme,
                        mService.compatibilityInfoForPackageLocked(
                                r.info.applicationInfo), r.nonLocalizedLabel,
                        r.labelRes, r.icon, r.logo, r.windowFlags,
                        prev != null ? prev.appToken : null, showStartingIcon);
            }
        } else {
 .....//省略其他代码
        }

 .....//省略其他代码

        if (doResume) {
            mStackSupervisor.resumeTopActivitiesLocked();
        }
    }
```
将要启动的Activity在system_server端准备好以后，就开始处理launcher，首先是pause，然后是stop，launcher处理完成后才开始启动Activity
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
    boolean resumeTopActivitiesLocked() {
        //三个参数都是null，其实是要pause掉launch，
        //后面要resume需要启动的Activity时候，就不是null了
        return resumeTopActivitiesLocked(null, null, null);
    }

    boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) {
        if (targetStack == null) {
            targetStack = getFocusedStack();//取到将要启动的ActivityStack
        }
        boolean result = false;
        for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
            final ActivityStack stack = mStacks.get(stackNdx);
            if (isFrontStack(stack)) {
                if (stack == targetStack) {//进到这里
                    result = stack.resumeTopActivityLocked(target, targetOptions);
                } else {
                    stack.resumeTopActivityLocked(null);
                }
            }
        }
        return result;
    }

```

调用将要启动的Acitvity的`ActivityStack`对象的`resumeTopActivitiesLocked()`函数，
这里主要是让launcher进入pause状态，这个过程是异步操作，也是跨进程的涉及到本进程system_server和launcher进程。
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStack.java
   final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {

        // Find the first activity that is not finishing.
        ActivityRecord next = topRunningActivityLocked(null);//取到将要启动的ActivityRecord

        // Remember how we'll process this pause/resume situation, and ensure
        // that the state is reset however we wind up proceeding.
        //在前面startActivityUncheckedLocked中初始化mUserLeaving
        final boolean userLeaving = mStackSupervisor.mUserLeaving;
        mStackSupervisor.mUserLeaving = false;

        .....//省略其他代码

        // The activity may be waiting for stop, but that is no longer
        // appropriate for it.
        mStackSupervisor.mStoppingActivities.remove(next);
        mStackSupervisor.mGoingToSleepActivities.remove(next);
        next.sleeping = false;
        mStackSupervisor.mWaitingVisibleActivities.remove(next);

        .....//省略其他代码

        // We need to start pausing the current activity so the top one
        // can be resumed...
        //把launcher进入pause的过程是异步的，具体分析在resumeTopActivityLocked-pauseBackStacks，
        //pausing = 1
        boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving);
        
        if (pausing) {
            .....//省略其他代码

            return true;//函数返回，在pauseBackStacks的异步过程完成后又回调这个函数，
                        //下次进这个函数就不到这里了
     }
        
        .....//省略其他代码

    }
```

resumeTopActivityLocked-pauseBackStacks:
开始把launcher设置为pause状态。
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
    boolean pauseBackStacks(boolean userLeaving) {
        boolean someActivityPaused = false;
        for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
            final ActivityStack stack = mStacks.get(stackNdx);

            //只要不是最前面的ActivityStack，并且ActivityStack中已经有resume过的ActivityStack都会被pause
            if (!isFrontStack(stack) && stack.mResumedActivity != null) {
                if (DEBUG_STATES) Slog.d(TAG, "pauseBackStacks: stack=" + stack +
                        " mResumedActivity=" + stack.mResumedActivity);
                stack.startPausingLocked(userLeaving, false);	//显然找到的stack是launcher的
                someActivityPaused = true;
            }
        }
        return someActivityPaused;
    }
```

这里是进入到了launch的ActivityStack
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStack.java
    final void startPausingLocked(boolean userLeaving, boolean uiSleeping) {
        .....//省略其他代码

        //launcher还是resumed状态，这里要转成pause
        ActivityRecord prev = mResumedActivity;

        .....//省略其他代码

        mResumedActivity = null;
        mPausingActivity = prev;
        mLastPausedActivity = prev;
        mLastNoHistoryActivity = (prev.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (prev.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0 ? prev : null;
        prev.state = ActivityState.PAUSING;
        prev.task.touchActiveTime();
        clearLaunchTime(prev);
        
        //next = 即将启动的activity
        final ActivityRecord next = mStackSupervisor.topRunningActivityLocked();

        if (next == null || next.task != prev.task) {
            prev.updateThumbnail(screenshotActivities(prev), null);
        }
        stopFullyDrawnTraceIfNeeded();

        mService.updateCpuStats();

        if (prev.app != null && prev.app.thread != null) {
            if (DEBUG_PAUSE) Slog.v(TAG, "Enqueueing pending pause: " + prev);
            try {
                EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,
                        prev.userId, System.identityHashCode(prev),
                        prev.shortComponentName);
                mService.updateUsageStats(prev, false);

                //pause的异步操作，执行完schedulePauseActivity后就继续往下走，
                //具体在下面分析startPausingLocked-schedulePauseActivity
                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags);	

            } catch (Exception e) {
                // Ignore exception, if process died other code will cleanup.
                Slog.w(TAG, "Exception thrown during pause", e);
                mPausingActivity = null;
                mLastPausedActivity = null;
                mLastNoHistoryActivity = null;
            }
        } else {
                .....//省略其他代码
        }

        // If we are not going to sleep, we want to ensure the device is
        // awake until the next activity is started.
        if (!mService.isSleepingOrShuttingDown()) {
            mStackSupervisor.acquireLaunchWakelock();//屏幕不休眠
        }

        if (mPausingActivity != null) {
            // Have the window manager pause its key dispatching until the new
            // activity has started.  If we're pausing the activity just because
            // the screen is being turned off and the UI is sleeping, don't interrupt
            // key dispatch; the same activity will pick it up again on wakeup.
            if (!uiSleeping) {
                prev.pauseKeyDispatchingLocked();
            } else {
                if (DEBUG_PAUSE) Slog.v(TAG, "Key dispatch not paused for screen off");
            }

            // Schedule a pause timeout in case the app doesn't respond.
            // We don't give it much time because this directly impacts the
            // responsiveness seen by the user.
            Message msg = mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);
            msg.obj = prev;
            prev.pauseTime = SystemClock.uptimeMillis();

            //PAUSE_TIMEOUT = 500,等待时间到了就handleMessage
            mHandler.sendMessageDelayed(msg, PAUSE_TIMEOUT);

            if (DEBUG_PAUSE) Slog.v(TAG, "Waiting for pause to complete...");
        } else {
            .....//省略其他代码
        }
    }
```

`mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);`就是加了一个超时处理，
如果launcher在500毫秒内没能pause并且resume将要启动的Activity，
那么Handler会去pause并且resume将要启动的Acitvity。  
无论是launcher还是Handler，都会走到同样的入口`activityPausedLocked`。

startPausingLocked-schedulePauseActivity:
当前是在system_server进程，需要pause的app在各自进程中执行pause
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/ApplicationThreadNative.java
    public final void schedulePauseActivity(IBinder token, boolean finished,
            boolean userLeaving, int configChanges) throws RemoteException {
        Parcel data = Parcel.obtain();
        data.writeInterfaceToken(IApplicationThread.descriptor);
        data.writeStrongBinder(token);
        data.writeInt(finished ? 1 : 0);
        data.writeInt(userLeaving ? 1 :0);
        data.writeInt(configChanges);

        //IBinder.FLAG_ONEWAY是发完transact就返回，不等待结果
        mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, null,
                IBinder.FLAG_ONEWAY);
        data.recycle();
    }
```

进入到launcher进程即是应用程序自己的进程中执行pause并且调用Activity的生命周期函数，应用程序就可以管理自己的Activity。  
不在system_server进程中执行pause，是因为system_server进程是系统进程，还需要处理其他事务，不能被某一个应用程序影响。
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/ActivityThread.java
    private void handlePauseActivity(IBinder token, boolean finished,
            boolean userLeaving, int configChanges) {

        //token是ActivityRecord的内部类Token
        //所以ActivityRecord与ActivityClientRecord是一一对应
        ActivityClientRecord r = mActivities.get(token);
        if (r != null) {
            //Slog.v(TAG, "userLeaving=" + userLeaving + " handling pause of " + r);
            if (userLeaving) {
                //调用Activity的生命周期方法
               //onUserInteraction();onUserLeaveHint();
                performUserLeavingActivity(r);
            }

            r.activity.mConfigChangeFlags |= configChanges;

            //调用Activity的生命周期方法
            //onSaveInstanceState、saveManagedDialogs、onPause
            performPauseActivity(token, finished, r.isPreHoneycomb());

            // Make sure any pending writes are now committed.
            if (r.isPreHoneycomb()) {
                QueuedWork.waitToFinish();
            }

            // Tell the activity manager we have paused.
            try {
                //通知ActivityManagerService改变状态等处理
                ActivityManagerNative.getDefault().activityPaused(token);
            } catch (RemoteException ex) {
            }
        }
    }
```

`activityPaused`参数是IBinder，又回到了system_server进程调用ActivityManagerService。  
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
    public final void activityPaused(IBinder token) {
        final long origId = Binder.clearCallingIdentity();
        synchronized(this) {
            ActivityStack stack = ActivityRecord.getStackLocked(token);
            if (stack != null) {
                stack.activityPausedLocked(token, false);
            }
        }
        Binder.restoreCallingIdentity(origId);
    }
```
pause的收尾工作，调用Activity生命周期函数onStop，处理Activity的隐藏、缩略图等
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStack.java
    final void activityPausedLocked(IBinder token, boolean timeout) {

	final ActivityRecord r = isInStackLocked(token);
        if (r != null) {
            mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);//移除超时msg
            if (mPausingActivity == r) {
                if (DEBUG_STATES) Slog.v(TAG, "Moving to PAUSED: " + r
                        + (timeout ? " (due to timeout)" : " (pause complete)"));
                r.state = ActivityState.PAUSED;
                completePauseLocked();//pause完成了就要resume需要启动的Activity
            } 
	....//省略其他代码
        }
	
    }

    private void completePauseLocked() {
        ActivityRecord prev = mPausingActivity;//指向launcher
        if (DEBUG_PAUSE) Slog.v(TAG, "Complete pause: " + prev);

        if (prev != null) {
            if (prev.finishing) {

                ....//省略其他代码

            } else if (prev.app != null) {
                
                ....//省略其他代码
                
                if (prev.configDestroy) {

                    ....//省略其他代码

                } else {
                    
                    //加入到mStoppingActivities，下一步函数取出
                    mStackSupervisor.mStoppingActivities.add(prev);

                    //launcher进入stop状态处理
                    if (mStackSupervisor.mStoppingActivities.size() > 3 ||
                            prev.frontOfTask && mTaskHistory.size() <= 1) {
                        // If we already have a few activities waiting to stop,
                        // then give up on things going idle and start clearing
                        // them out. Or if r is the last of activity of the last task the stack
                        // will be empty and must be cleared immediately.
                        if (DEBUG_PAUSE) Slog.v(TAG, "To many pending stops, forcing idle");
                        //Idle状态包括了stop和destroy，目前是处理stop
                        //具体分析在completePauseLocked-scheduleIdleLocked
                        mStackSupervisor.scheduleIdleLocked();
                    } else {
                        mStackSupervisor.checkReadyForSleepLocked();
                    }
                }
            } else {
                if (DEBUG_PAUSE) Slog.v(TAG, "App died during pause, not stopping: " + prev);
                prev = null;
            }
            mPausingActivity = null;
        }

        final ActivityStack topStack = mStackSupervisor.getFocusedStack();
        if (!mService.isSleepingOrShuttingDown()) {
            //resume将要启动的Activity，这时的参数就不是全部null
            //具体见下面completePauseLocked-resumeTopActivitiesLocked
            mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null);
        } 
        ....//省略其他代码

    }
```

completePauseLocked-scheduleIdleLocked：
让launcher进入stop
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
    final void scheduleIdleLocked() {
        mHandler.sendEmptyMessage(IDLE_NOW_MSG);
    }

    public void handleMessage(Message msg) {
    switch (msg.what) {

        ....//省略其他代码

        case IDLE_NOW_MSG: {
            if (DEBUG_IDLE) Slog.d(TAG, "handleMessage: IDLE_NOW_MSG: r=" + msg.obj);
            //sendEmptyMessage,所以msg.obj是null
            activityIdleInternal((ActivityRecord)msg.obj);
        } break;

        ....//省略其他代码
    }
}

        //r是null
    void activityIdleInternal(ActivityRecord r) {
        synchronized (mService) {
            activityIdleInternalLocked(r != null ? r.appToken : null, true, null);
        }
    }

    final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) {

        ArrayList<ActivityRecord> stops = null;

        //token是null，所以r也是null
        ActivityRecord r = ActivityRecord.forToken(token);

        ....//省略其他代码

        // Atomically retrieve all of the other things to do.

        //从上面的mStackSupervisor.mStoppingActivities中取出
        stops = processStoppingActivitiesLocked(true);
        NS = stops != null ? stops.size() : 0;
        
        ....//省略其他代码

        // Stop any activities that are scheduled to do so but have been
        // waiting for the next one to start.
        for (int i = 0; i < NS; i++) {
            r = stops.get(i);
            final ActivityStack stack = r.task.stack;
            if (r.finishing) {
                stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false);
            } else {
                //具体分析在activityIdleInternalLocked-stopActivityLocked
                stack.stopActivityLocked(r);
            }
        }

   ....//省略其他代码
}
```

activityIdleInternalLocked-stopActivityLocked:
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStack.java
    final void stopActivityLocked(ActivityRecord r) {   
        
        ....//省略其他代码

        if (r.app != null && r.app.thread != null) {
            adjustFocusedActivityLocked(r);
            r.resumeKeyDispatchingLocked();
            try {
                r.stopped = false;
                if (DEBUG_STATES) Slog.v(TAG, "Moving to STOPPING: " + r
                        + " (stop requested)");

                //更新前面赋值的ActivityState.PAUSED;
                r.state = ActivityState.STOPPING;
                if (DEBUG_VISBILITY) Slog.v(
                        TAG, "Stopping visible=" + r.visible + " for " + r);
                if (!r.visible) {
                    mWindowManager.setAppVisibility(r.appToken, false);
                }

                //一样还是在应用进程中处理stop
                //具体分析在stopActivityLocked-scheduleStopActivity
                r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags);
                if (mService.isSleepingOrShuttingDown()) {
                    r.setSleeping(true);
                }

                //超时处理，如果超时的话，并不会等待应用进程，而是ActivityManagerService直接把被stop的App调整为previous app，将要resume的app调整为foreground app
                Message msg = mHandler.obtainMessage(STOP_TIMEOUT_MSG, r);
                mHandler.sendMessageDelayed(msg, STOP_TIMEOUT);
            } catch (Exception e) {
                // Maybe just ignore exceptions here...  if the process
                // has crashed, our death notification will clean things
                // up.
                Slog.w(TAG, "Exception thrown during pause", e);
                // Just in case, assume it to be stopped.
                r.stopped = true;
                if (DEBUG_STATES) Slog.v(TAG, "Stop failed; moving to STOPPED: " + r);
                r.state = ActivityState.STOPPED;
                if (r.configDestroy) {
                    destroyActivityLocked(r, true, false, "stop-except");
                }
            }
        }
    }
```
stopActivityLocked-scheduleStopActivity：
通过sendMessage放到主线程的消息队列中执行StopActivity。
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/ActivityThread.java
    public final void scheduleStopActivity(IBinder token, boolean showWindow,
            int configChanges) {
       sendMessage(
            showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE,
            token, 0, configChanges);
    }

    //主要做了三个工作：
    //1. 调用Activity生命周期函数onStop函数
    //2. 在decor view中设置Activity为不可见
    //3. 通知ActivityManagerService已经完成Activity的stop 
    private void handleStopActivity(IBinder token, boolean show, int configChanges) {
        ActivityClientRecord r = mActivities.get(token);
        r.activity.mConfigChangeFlags |= configChanges;

        StopInfo info = new StopInfo();

        //调用onStop函数
        performStopActivityInner(r, info, show, true);

        if (localLOGV) Slog.v(
            TAG, "Finishing stop of " + r + ": show=" + show
            + " win=" + r.window);

        //更新decor View
        updateVisibility(r, show);

        // Make sure any pending writes are now committed.
        if (!r.isPreHoneycomb()) {
            QueuedWork.waitToFinish();
        }

        // Schedule the call to tell the activity manager we have
        // stopped.  We don't do this immediately, because we want to
        // have a chance for any other pending work (in particular memory
        // trim requests) to complete before you tell the activity
        // manager to proceed and allow us to go fully into the background.
        info.activity = r;
        info.state = r.state;

        // post到主线程的消息队列中等待执行，是为了让主线程中所有任务都完成了再告知ActivityManagerService该Activity已经stop
        mH.post(info);
    }

    private static class StopInfo implements Runnable {
        ActivityClientRecord activity;
        Bundle state;
        Bitmap thumbnail;
        CharSequence description;

        @Override public void run() {
            // Tell activity manager we have been stopped.
            try {
                if (DEBUG_MEMORY_TRIM) Slog.v(TAG, "Reporting activity stopped: " + activity);

                //主要是把被stop的App调整为previous app，将要resume的app调整为foreground app
                ActivityManagerNative.getDefault().activityStopped(
                    activity.token, state, thumbnail, description);
            } catch (RemoteException ex) {
            }
        }
    }
```

completePauseLocked-resumeTopActivitiesLocked：
调用ActivityStackSupervisor的resume，最终还是一样到ActivityStack的resume
`targetStack`是将要启动的ActivityStack  
`target`是被pause的launch
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
    boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) {
        if (targetStack == null) {
            targetStack = getFocusedStack();
        }
        boolean result = false;
        for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
            final ActivityStack stack = mStacks.get(stackNdx);
            if (isFrontStack(stack)) {
                if (stack == targetStack) {
                    result = stack.resumeTopActivityLocked(target, targetOptions);
                } else {
                    stack.resumeTopActivityLocked(null);
                }
            }
        }
        return result;
    }
```

进入launch的ActivityStack，主要是处理与显示有关的逻辑，与WindowManagerServer有关
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStack.java
    final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {
        if (ActivityManagerService.DEBUG_LOCKSCREEN) mService.logLockScreen("");

        // Find the first activity that is not finishing.
        ActivityRecord next = topRunningActivityLocked(null);//即将resume的Activity

        // Remember how we'll process this pause/resume situation, and ensure
        // that the state is reset however we wind up proceeding.
        final boolean userLeaving = mStackSupervisor.mUserLeaving;//false
        mStackSupervisor.mUserLeaving = false;

        ....//省略其他代码
 
        // The activity may be waiting for stop, but that is no longer
        // appropriate for it.
        mStackSupervisor.mStoppingActivities.remove(next);
        mStackSupervisor.mGoingToSleepActivities.remove(next);
        next.sleeping = false;
        mStackSupervisor.mWaitingVisibleActivities.remove(next);

        next.updateOptionsLocked(options);

        ....//省略其他代码


        //把launcher转成WaitingVisible
        if (prev != null && prev != next) {
            if (!prev.waitingVisible && next != null && !next.nowVisible) {
                prev.waitingVisible = true;
                mStackSupervisor.mWaitingVisibleActivities.add(prev);
                
                if (DEBUG_SWITCH) Slog.v(
                        TAG, "Resuming top, waiting visible to hide: " + prev);
            } 

         ....//省略其他代码
        }

        // Launching this app's activity, make sure the app is no longer
        // considered stopped.
        try {
            AppGlobals.getPackageManager().setPackageStoppedState(
                    next.packageName, false, next.userId); /* TODO: Verify if correct userid */
        } catch (RemoteException e1) {
        } catch (IllegalArgumentException e) {
            Slog.w(TAG, "Failed trying to unstop package "
                    + next.packageName + ": " + e);
        }

        // We are starting up the next activity, so tell the window manager
        // that the previous one will be hidden soon.  This way it can know
        // to ignore it when computing the desired screen orientation.
        boolean anim = true;
        if (prev != null) {
            if (prev.finishing) {
            ....//省略其他代码

            } else {
                if (DEBUG_TRANSITION) Slog.v(TAG, "Prepare open transition: prev=" + prev);
                if (mNoAnimActivities.contains(next)) {
                    anim = false;
                    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false);
                } else {
                    //Activity切换时的动画效果
                    mWindowManager.prepareAppTransition(prev.task == next.task
                            ? AppTransition.TRANSIT_ACTIVITY_OPEN
                            : AppTransition.TRANSIT_TASK_OPEN, false);
                }
            }
            ....//省略其他代码
        } else {
            ....//省略其他代码
        }
        if (anim) {
            next.applyOptionsLocked();//设置启动动画相关
        } else {
            next.clearOptionsLocked();
        }

        ActivityStack lastStack = mStackSupervisor.getLastStack();
        if (next.app != null && next.app.thread != null) {

        ....//省略其他代码
        } else {
            // Whoops, need to restart this activity!
            if (!next.hasBeenLaunched) {
                next.hasBeenLaunched = true;//
            } else {
                if (SHOW_APP_STARTING_PREVIEW) {
                    mWindowManager.setAppStartingWindow(
                            next.appToken, next.packageName, next.theme,
                            mService.compatibilityInfoForPackageLocked(
                                    next.info.applicationInfo),
                            next.nonLocalizedLabel,
                            next.labelRes, next.icon, next.logo, next.windowFlags,
                            null, true);
                }
                if (DEBUG_SWITCH) Slog.v(TAG, "Restarting: " + next);
            }
            if (DEBUG_STATES) Slog.d(TAG, "resumeTopActivityLocked: Restarting " + next);
            mStackSupervisor.startSpecificActivityLocked(next, true, true);//准备启动Activity
        }

        if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
        return true;
    }
```

`startSpecificActivityLocked`的参数只有即将启动的Activity，和launcher没关系了。  
其实也是进入到下半部分，开启新进程来运行这个应用。
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
    void startSpecificActivityLocked(ActivityRecord r,
            boolean andResume, boolean checkConfig) {

        ....//省略其他代码
        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
                "activity", r.intent.getComponent(), false, false, true);
    }
```
创建ProcessRecord对象,主要包含ApplicationInfo和processName，
开启一个新进程用于即将启动的Activity应用
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
    final ProcessRecord startProcessLocked(String processName,
            ApplicationInfo info, boolean knownToBeDead, int intentFlags,
            String hostingType, ComponentName hostingName, boolean allowWhileBooting,
            boolean isolated, boolean keepIfLarge) {
        ProcessRecord app;
 
        ....//省略其他代码

        String hostingNameStr = hostingName != null
                ? hostingName.flattenToShortString() : null;

        ....//省略其他代码

        if (app == null) {
            app = newProcessRecordLocked(info, processName, isolated);
            if (app == null) {
                Slog.w(TAG, "Failed making new process record for "
                        + processName + "/" + info.uid + " isolated=" + isolated);
                return null;
            }
            mProcessNames.put(processName, app.uid, app);
            if (isolated) {
                mIsolatedProcesses.put(app.uid, app);
            }
        } 
     
        ....//省略其他代码

        startProcessLocked(app, hostingType, hostingNameStr);
        return (app.pid != 0) ? app : null;
    }

    private final void startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr) {
   
        ....//省略其他代码

        try {
            ....//省略其他代码

            // Start the process.  It will either succeed and return a result containing
            // the PID of the new process, or else throw a RuntimeException.
            //参数"android.app.ActivityThread"是指新进程开始运行的类  
            Process.ProcessStartResult startResult = Process.start("android.app.ActivityThread",
                    app.processName, uid, uid, gids, debugFlags, mountExternal,
                    app.info.targetSdkVersion, app.info.seinfo, null);//开启新进程

            ....//省略其他代码

            synchronized (mPidsSelfLocked) {
                this.mPidsSelfLocked.put(startResult.pid, app);//新进程保存到数组，后面会使用到

                //增加超时处理
                //如果在PROC_START_TIMEOUT = 10*1000 毫秒内，进程不能完成启动，该进程会被kill掉
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper
                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        } catch (RuntimeException e) {
            // XXX do better error recovery.
            app.setPid(0);
            Slog.e(TAG, "Failure starting process " + app.processName, e);
        }
    }
```


## [](#header-2)4.2 zygote的fork过程源码分析

```java
///android-4.4.4_r1/frameworks/base/core/java/android/os/Process.java
    public static final ProcessStartResult start(final String processClass,
                                  final String niceName,
                                  int uid, int gid, int[] gids,
                                  int debugFlags, int mountExternal,
                                  int targetSdkVersion,
                                  String seInfo,
                                  String[] zygoteArgs) {
        try {
            return startViaZygote(processClass, niceName, uid, gid, gids,
                    debugFlags, mountExternal, targetSdkVersion, seInfo, zygoteArgs);
        } catch (ZygoteStartFailedEx ex) {
            Log.e(LOG_TAG,
                    "Starting VM process through Zygote failed");
            throw new RuntimeException(
                    "Starting VM process through Zygote failed", ex);
        }
    }

    private static ProcessStartResult startViaZygote(final String processClass,
                                  final String niceName,
                                  final int uid, final int gid,
                                  final int[] gids,
                                  int debugFlags, int mountExternal,
                                  int targetSdkVersion,
                                  String seInfo,
                                  String[] extraArgs)
                                  throws ZygoteStartFailedEx {
        synchronized(Process.class) {
 
            ....//省略其他代码

            return zygoteSendArgsAndGetResult(argsForZygote);
        }
    }

    private static ProcessStartResult zygoteSendArgsAndGetResult(ArrayList<String> args)
            throws ZygoteStartFailedEx {
        openZygoteSocketIfNeeded();//连接zygote的socket

        try {
            /**
             * See com.android.internal.os.ZygoteInit.readArgumentList()
             * Presently the wire format to the zygote process is:
             * a) a count of arguments (argc, in essence)
             * b) a number of newline-separated argument strings equal to count
             *
             * After the zygote process reads these it will write the pid of
             * the child or -1 on failure, followed by boolean to
             * indicate whether a wrapper process was used.
             */

            sZygoteWriter.write(Integer.toString(args.size()));
            sZygoteWriter.newLine();

            int sz = args.size();
            for (int i = 0; i < sz; i++) {
                String arg = args.get(i);
                if (arg.indexOf('\n') >= 0) {
                    throw new ZygoteStartFailedEx(
                            "embedded newlines not allowed");
                }
                sZygoteWriter.write(arg);//socket写数据到缓存
                sZygoteWriter.newLine();
            }

            sZygoteWriter.flush();//数据发出去

            // Should there be a timeout on this?
            ProcessStartResult result = new ProcessStartResult();
            result.pid = sZygoteInputStream.readInt();//fork出来的pid

            ....//省略其他代码
        }
 
        ....//省略其他代码
    }

```

socket的另一端zygote在函数`runSelectLoop`中等待接收数据然后fork出新进程。
```java
///android-4.4.4_r1/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
    private static void runSelectLoop() throws MethodAndArgsCaller {

        ....//省略其他代码

        fds.add(sServerSocket.getFileDescriptor());
        peers.add(null);

        while (true) {
            int index;

            ....//省略其他代码
 
            try {
                fdArray = fds.toArray(fdArray);
                index = selectReadable(fdArray);
            } catch (IOException ex) {
                throw new RuntimeException("Error in select()", ex);
            }

            if (index < 0) {
                throw new RuntimeException("Error in select()");
            } else if (index == 0) {
                
                //ZygoteConnection中创建一个LocalScoket与sServerSocket通信
                ZygoteConnection newPeer = acceptCommandPeer();         
                peers.add(newPeer);
                fds.add(newPeer.getFileDesciptor());
            } else {
                boolean done;
                done = peers.get(index).runOnce();//接收到数据

                if (done) {
                    peers.remove(index);
                    fds.remove(index);
                }
            }
        }
    }

    boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {

        ....//省略其他代码

        try {
        
        ....//省略其他代码

            //创建新进程,调用到native层，最终是由Linux内核创建出新进程
            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
                    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
                    parsedArgs.niceName);
        }
   
        ....//省略其他代码

        try {
            if (pid == 0) {//创建成功
                // in child
                IoUtils.closeQuietly(serverPipeFd);
                serverPipeFd = null;
                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);//子进程逻辑处理

                // should never get here, the child is expected to either
                // throw ZygoteInit.MethodAndArgsCaller or exec().
                return true;
            } else {
                // in parent...pid of < 0 means failure
                IoUtils.closeQuietly(childPipeFd);
                childPipeFd = null;
                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);
            }
        } finally {
            IoUtils.closeQuietly(childPipeFd);
            IoUtils.closeQuietly(serverPipeFd);
        }
    }

    private void handleChildProc(Arguments parsedArgs,
            FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)
            throws ZygoteInit.MethodAndArgsCaller {

        closeSocket();//关闭从zyogte继承的socket，是ZygoteConnection中创建的LocalScoket
        ZygoteInit.closeServerSocket();//关闭从zyogte继承的sServerSocket

        ....//省略其他代码

        if (parsedArgs.niceName != null) {
            Process.setArgV0(parsedArgs.niceName);//设置进程名
        }

        ....//省略其他代码

                    //parsedArgs.classpath = android.app.ActivityThread
                    //已安装的包用PathClassLoader，未安装的用DexClassLoader
                    cloader = new PathClassLoader(parsedArgs.classpath,
                            ClassLoader.getSystemClassLoader());
 
        ....//省略其他代码
                    
                    //调用ActivityThread的main函数
                    ZygoteInit.invokeStaticMain(cloader, className, mainArgs);

        ....//省略其他代码
      
            }
        }
    }
```

## [](#header-2)4.3 myapplication的启动源码分析

在新进程中进入到`ActivityThread`的`main`函数，主要做了两件事：  
一是创建主线程的looper并且进入消息循环  
二是创建ActivityThread对象，虽然名字中有Thread，但它并没有直接继承Thread，也就是说ActivityThread
不是Thread类型，确切的说是管理主线程的对象
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/ActivityThread.java

//ApplicationThread是ActivityThread的内部类，继承Binder类型，是ActivityThread进行进程间通信的接口
final ApplicationThread mAppThread = new ApplicationThread();

   public static void main(String[] args) {

        ....//省略其他代码

        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        ....//省略其他代码

        Looper.loop();

        ....//省略其他代码
    }

    private void attach(boolean system) {
        sCurrentActivityThread = this;
        mSystemThread = system;
        if (!system) {
            
            ....//省略其他代码

            IActivityManager mgr = ActivityManagerNative.getDefault();
            try {
                //与ActivityManagerService建立联系
                //阻塞调用
                mgr.attachApplication(mAppThread);
            } catch (RemoteException ex) {
                // Ignore
            }
        } 

        ....//省略其他代码
    }
```
`ApplicationThread`是`ActivityThread`的内部类，具体的类图如下
![]({{ site.url }}/android/images/apk-start/ApplicationThread.png)  
从图中看出，ApplicationThread本质上是Binder对象，其实是作为ActivityThread实现进程间通信的接口，
主要是用于ActivityManagerService进行应用管理。

```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
            int callingPid = Binder.getCallingPid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        }
    }

    private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {

        // Find the application record that is being attached...  either via
        // the pid if we are running in multiple processes, or just pull the
        // next app record if we are emulating process with anonymous threads.
        ProcessRecord app;
        if (pid != MY_PID && pid >= 0) {
            synchronized (mPidsSelfLocked) {
                app = mPidsSelfLocked.get(pid);//在startProcessLocked中add
            }
        } else {
            app = null;
        }

        ....//省略其他代码


        //ProcessRecord通过IApplicationThread与ActivityThread建立关系
        //记录app的ProcessState
        app.makeActive(thread, mProcessStats);

        ....//省略其他代码

        //移除掉前面添加的超时处理消息
        mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);

        boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);

        ....//省略其他代码

        try {

            ....//省略其他代码

            //app.compat是CompatibilityInfo类型，由ApplicationInfo生成
            app.compat = compatibilityInfoForPackageLocked(appInfo);

            //下面具体分析attachApplicationLocked-bindApplication
            thread.bindApplication(processName, appInfo, providers,
                    app.instrumentationClass, profileFile, profileFd, profileAutoStop,
                    app.instrumentationArguments, app.instrumentationWatcher,
                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),
                    mCoreSettingsObserver.getCoreSettingsLocked());

            //更新mLruProcesses，app为最顶上元素
            updateLruProcessLocked(app, false, null);
            app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
        } 
        ....//省略其他代码

        boolean badApp = false;
        boolean didSomething = false;

        // See if the top visible activity is waiting to run in this process...
        if (normalMode) {
            try {
                //下面具体分析attachApplicationLocked-mStackSupervisor.attachApplicationLocked
                if (mStackSupervisor.attachApplicationLocked(app, mHeadless)) {
                    didSomething = true;
                }
            } catch (Exception e) {
                badApp = true;
            }
        }

        // Find any services that should be running in this process...
        if (!badApp) {
            try {
                //mServices是ActiveServices，这里是启动应用中的service
                didSomething |= mServices.attachApplicationLocked(app, processName);
            } catch (Exception e) {
                badApp = true;
            }
        }

        ....//省略其他代码

        //增加新应用所以更新oom
        if (!didSomething) {
            updateOomAdjLocked();
        }

        return true;
    }
```

attachApplicationLocked-bindApplication：
`bindApplication`在应用程序进程中执行，主要工作是创建对象：  
1）创建LoadedApk对象  
2）创建Instrumentation对象  
3）创建Application对象，先需要创建ContextImpl对象，然后由Instrumentation用反射方法创建Application对象，
并且把接口Context的实现指向ContextImpl，Application保存了LoadedApk对象  
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/ActivityThread.java
        public final void bindApplication(String processName,
                ApplicationInfo appInfo, List<ProviderInfo> providers,
                ComponentName instrumentationName, String profileFile,
                ParcelFileDescriptor profileFd, boolean autoStopProfiler,
                Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher,
                IUiAutomationConnection instrumentationUiConnection, int debugMode,
                boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,
                Configuration config, CompatibilityInfo compatInfo, Map<String, IBinder> services,
                Bundle coreSettings) {

            //在应用程序进程中缓存了server代理
            if (services != null) {
                // Setup the service cache in the ServiceManager
                ServiceManager.initServiceCache(services);
            }

            ....//省略其他代码

            sendMessage(H.BIND_APPLICATION, data);//调用handleBindApplication
        }

    private void handleBindApplication(AppBindData data) {

        ....//省略其他代码

        //更改了进程名称
        // send up app name; do this *before* waiting for debugger
        Process.setArgV0(data.processName);
        android.ddm.DdmHandleAppName.setAppName(data.processName,
                                                UserHandle.myUserId());
        ....//省略其他代码

        //data.info是LoadedApk类型对象
        //data.compatInfo也是由data.appInfo生成，在前面attachApplicationLocked函数中
        data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);

        ....//省略其他代码
        

        //显示waiting for debugger的对话框，是在系统进程中显示
        if (data.debugMode != IApplicationThread.DEBUG_OFF) {
            // XXX should have option to change the port.
            Debug.changeDebugPort(8100);
            if (data.debugMode == IApplicationThread.DEBUG_WAIT) {
                Slog.w(TAG, "Application " + data.info.getPackageName()
                      + " is waiting for the debugger on port 8100...");

                IActivityManager mgr = ActivityManagerNative.getDefault();
                try {
                    mgr.showWaitingForDebugger(mAppThread, true);
                } catch (RemoteException ex) {
                }

                Debug.waitForDebugger();

                try {
                    mgr.showWaitingForDebugger(mAppThread, false);
                } catch (RemoteException ex) {
                }

            } else {
                Slog.w(TAG, "Application " + data.info.getPackageName()
                      + " can be debugged on port 8100...");
            }
        }

        ....//省略其他代码

        if (data.instrumentationName != null) {

        ....//省略其他代码

        } else {
            mInstrumentation = new Instrumentation();//构造函数是空函数
        }

        ....//省略其他代码

        try {
            // If the app is being launched for full backup or restore, bring it up in
            // a restricted environment with the base application class.
           
            //创建Application对象，具体下面分析handleBindApplication-makeApplication
            Application app = data.info.makeApplication(data.restrictedBackupMode, null);
            mInitialApplication = app;

            ....//省略其他代码

            // Do this after providers, since instrumentation tests generally start their
            // test thread at this point, and we don't want that racing.
            try {
                mInstrumentation.onCreate(data.instrumentationArgs);//空函数
            }
            catch (Exception e) {
                throw new RuntimeException(
                    "Exception thrown in onCreate() of "
                    + data.instrumentationName + ": " + e.toString(), e);
            }

            try {
                //Application的OnCreate函数回调
                mInstrumentation.callApplicationOnCreate(app);
            } catch (Exception e) {
                if (!mInstrumentation.onException(app, e)) {
                    throw new RuntimeException(
                        "Unable to create application " + app.getClass().getName()
                        + ": " + e.toString(), e);
                }
            }
        } finally {
            StrictMode.setThreadPolicy(savedPolicy);
        }
    }
```
handleBindApplication-makeApplication：  
创建Application对象
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/LoadedApk.java
    public Application makeApplication(boolean forceDefaultAppClass,
            Instrumentation instrumentation) {

        ....//省略其他代码

        //如果没有自定义Application的子类，则系统默认生成Application对象
        Application app = null;
        String appClass = mApplicationInfo.className;
        if (forceDefaultAppClass || (appClass == null)) {
            appClass = "android.app.Application";
        }

        try {
            //返回类型是PathClassLoader
            java.lang.ClassLoader cl = getClassLoader();

            //创建ContextImpl对象，并且保存了ActivityThread、LoadedApk相关信息
            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);

            //有ClassLoader和类名，显然是用反射的方法创建Application对象
            //然后把生成的对象Application的接口类Context的实现指向appContext
            //具体分析见下面makeApplication-newApplication
            app = mActivityThread.mInstrumentation.newApplication(
                    cl, appClass, appContext);
            appContext.setOuterContext(app);
        } catch (Exception e) {
            if (!mActivityThread.mInstrumentation.onException(app, e)) {
                throw new RuntimeException(
                    "Unable to instantiate application " + appClass
                    + ": " + e.toString(), e);
            }
        }
        mActivityThread.mAllApplications.add(app);
        mApplication = app;

        ....//省略其他代码
        
        return app;
    }
```
makeApplication-newApplication：
最终是调用到这里，具体看`attach`函数，它有两个作用，  
一是把ContextImpl赋给mBase，因为Application是继承ContextWrapper，mBase是ContextWrapper的成员变量，
所以最终是ContextWrapper的mBase指向ContextImpl，即是ContextImpl来实现接口Context；  
二是通过ContextImpl把LoadedApk对象保存到Application中。  
这样实现其实是装饰者模式的思想，具体可以看这篇《Android设计模式-装饰者》
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/Instrumentation.java
    public Application newApplication(ClassLoader cl, String className, Context context)
            throws InstantiationException, IllegalAccessException, 
            ClassNotFoundException {
        return newApplication(cl.loadClass(className), context);
    }
    static public Application newApplication(Class<?> clazz, Context context)
            throws InstantiationException, IllegalAccessException, 
            ClassNotFoundException {
        Application app = (Application)clazz.newInstance();
        app.attach(context);
        return app;
    }
    ///android-4.4.4_r1/frameworks/base/core/java/android/app/Application.java
    /* package */ final void attach(Context context) {
        attachBaseContext(context);
        mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;
    }
    protected void attachBaseContext(Context base) {
        if (mBase != null) {
            throw new IllegalStateException("Base context already set");
        }
        mBase = base;
    }    
```

attachApplicationLocked-mStackSupervisor.attachApplicationLocked：
`headless`是false，表示有屏幕，4.4以后的版本去掉了对无屏幕的支持
```java
///android-4.4.4_r1/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
    boolean attachApplicationLocked(ProcessRecord app, boolean headless) throws Exception {
        boolean didSomething = false;
        final String processName = app.processName;

        ....//省略其他代码

            ActivityRecord hr = stack.topRunningActivityLocked(null);
            if (hr != null) {
                //传进来的参数app就是要赋给hr.app
                if (hr.app == null && app.uid == hr.info.applicationInfo.uid
                        && processName.equals(hr.processName)) {
                    try {
                        if (headless) {
                            Slog.e(TAG, "Starting activities not supported on headless device: "
                                    + hr);
                        } else if (realStartActivityLocked(hr, app, true, true)) {
                            didSomething = true;
                        }
                    } catch (Exception e) {
                        Slog.w(TAG, "Exception in new application when starting activity "
                              + hr.intent.getComponent().flattenToShortString(), e);
                        throw e;
                    }
                }
            }
        
        ....//省略其他代码
    }
    
    final boolean realStartActivityLocked(ActivityRecord r,
            ProcessRecord app, boolean andResume, boolean checkConfig)
            throws RemoteException {

        ....//省略其他代码

        r.startFreezingScreenLocked(app, 0);
        if (false) Slog.d(TAG, "realStartActivity: setting app visibility true");
        //设置Activity可见，但没有在最顶层
        mWindowManager.setAppVisibility(r.appToken, true);

        // schedule launch ticks to collect information about slow apps.
        r.startLaunchTickingLocked();

        //ActivityRecord保存了ProcessRecord对象
        r.app = app;
 
        ....//省略其他代码

        try {

            ....//省略其他代码

            //在这里校验dex
            mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());

            ....//省略其他代码

            //回到应用进程去启动Activity
            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info,
                    new Configuration(mService.mConfiguration), r.compat,
                    app.repProcState, r.icicle, results, newIntents, !andResume,
                    mService.isNextTransitionForward(), profileFile, profileFd,
                    profileAutoStop);

            ....//省略其他代码

        } 

        ....//省略其他代码
    }
```

应用进程中收到Binder消息后，在本地创建`ActivityClientRecord`对象，把相应的信息从`ActivityRecord`中取出，
通过`sendMessage(H.LAUNCH_ACTIVITY, r);`启动Activity
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/ActivityThread.java

    public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
            ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo,
            int procState, Bundle state, List<ResultInfo> pendingResults,
            List<Intent> pendingNewIntents, boolean notResumed, boolean isForward,
            String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) {

        updateProcessState(procState, false);

        //创建ActivityClientRecord对象
        ActivityClientRecord r = new ActivityClientRecord();

        r.token = token;
        r.ident = ident;
        r.intent = intent;
        r.activityInfo = info;
        r.compatInfo = compatInfo;
        r.state = state;

        r.pendingResults = pendingResults;
        r.pendingIntents = pendingNewIntents;

        r.startsNotResumed = notResumed;
        r.isForward = isForward;

        r.profileFile = profileName;
        r.profileFd = profileFd;
        r.autoStopProfiler = autoStopProfiler;

        updatePendingConfiguration(curConfig);

        sendMessage(H.LAUNCH_ACTIVITY, r);
    }

    //处理H.LAUNCH_ACTIVITY
    private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {
 
        ....//省略其他代码

        //创建Activity对象，具体分析在下面handleLaunchActivity-performLaunchActivity
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            Bundle oldState = r.state;

            //通过WindowManager显示Activity，以及生命周期函数OnResume的调用
            //具体在下面handleLaunchActivity-handleResumeActivity
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed);

            ....//省略其他代码
        } 
        ....//省略其他代码
    }
```

handleLaunchActivity-performLaunchActivity：
`performLaunchActivity`主要是创建Activity以及生命周期函数OnCreate、OnStart的调用
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/ActivityThread.java
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {

        ....//省略其他代码

        Activity activity = null;
        try {
            //反射的方法创建Activity对象
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);

            ....//省略其他代码
        } 
        ....//省略其他代码

        try {
            //在handleBindApplication中已经创建了Application对象，这里直接返回mApplication
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

            ....//省略其他代码

            if (activity != null) {

                //创建Activity的Context，具体见下面分析performLaunchActivity-createBaseContextForActivity
                Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity "
                        + r.activityInfo.name + " with config " + config);

                //具体见下面分析performLaunchActivity-attach
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config);

                if (customIntent != null) {
                    activity.mIntent = customIntent;
                }
                r.lastNonConfigurationInstances = null;
                activity.mStartedActivity = false;
                int theme = r.activityInfo.getThemeResource();
                if (theme != 0) {
                    activity.setTheme(theme);
                }

                //调用Activity生命周期函数OnCreate,
                //然后把activity在ActivityMonitor中更新为最近使用的activity
                activity.mCalled = false;
                mInstrumentation.callActivityOnCreate(activity, r.state);
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        "Activity " + r.intent.getComponent().toShortString() +
                        " did not call through to super.onCreate()");
                }
                r.activity = activity;
                r.stopped = true;
                if (!r.activity.mFinished) {
                    //调用Activity生命周期函数OnStart
                    activity.performStart();
                    r.stopped = false;
                }

                ....//省略其他代码
            }
            r.paused = true;

            mActivities.put(r.token, r);

        } 

        ....//省略其他代码
    }
```
performLaunchActivity-createBaseContextForActivity：
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/ActivityThread.java
    private Context createBaseContextForActivity(ActivityClientRecord r,
            final Activity activity) {

        //与createAppContext不同的是多了一个r.token参数，即是Activity的IBinder对象，
        //IBinder在这里显然是被当做token来使用，每一个Activity都有一个自己的ContextImp来实现不同的需求
        //通过IBinder对象在ResourcesManager中获取到mResources对象，这样Activity就可以使用资源了，
        //除了IBinder和Resources以外，Activity的Context与Application的并无差别
        ContextImpl appContext = ContextImpl.createActivityContext(this, r.packageInfo, r.token);
        appContext.setOuterContext(activity);

        ....//省略其他代码
    }
```

performLaunchActivity-attach分析：  
1.把Activity与Context、ActivityThread、Instrumentation、Token、Application等对象进行绑定  
2.WindowManager相关操作
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/Activity.java
    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config) {

        //把接口类Context的实现指向createBaseContextForActivity创建的ContextImp对象
        attachBaseContext(context);

        //只是保存了这三个参数，其中null是指向parent的Fragments
        mFragments.attachActivity(this, mContainer, null);
        
        //初始化Window成员变量
        mWindow = PolicyManager.makeNewWindow(this);
        mWindow.setCallback(this);
        mWindow.getLayoutInflater().setPrivateFactory(this);
        if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
            mWindow.setSoftInputMode(info.softInputMode);
        }
        if (info.uiOptions != 0) {
            mWindow.setUiOptions(info.uiOptions);
        }

        //当前线程就是主线程也被指定为ui线程
        mUiThread = Thread.currentThread();
        
        //保存相关成员变量
        mMainThread = aThread;
        mInstrumentation = instr;
        mToken = token;
        mIdent = ident;
        mApplication = application;
        mIntent = intent;
        mComponent = intent.getComponent();
        mActivityInfo = info;
        mTitle = title;
        mParent = parent;
        mEmbeddedID = id;
        mLastNonConfigurationInstances = lastNonConfigurationInstances;

        //与WindowManager相关
        mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;
    }
```

handleLaunchActivity-handleResumeActivity:  
主要工作有：  
1.调用Activity生命周期函数OnResume  
2.WindowManagerService创建Window、DecorView等对象并且显示Activity  
3.更新ActivityRecord信息  
```java
///android-4.4.4_r1/frameworks/base/core/java/android/app/ActivityThread.java
    final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward,
            boolean reallyResume) {
        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();

        //调用Activity生命周期函数OnResume
        ActivityClientRecord r = performResumeActivity(token, clearHide);

        if (r != null) {
            final Activity a = r.activity;

            if (localLOGV) Slog.v(
                TAG, "Resume " + r + " started activity: " +
                a.mStartedActivity + ", hideForNow: " + r.hideForNow
                + ", finished: " + a.mFinished);

            //与WindowManagerServer相关的操作
            final int forwardBit = isForward ?
                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;

            // If the window hasn't yet been added to the window manager,
            // and this guy didn't finish itself or start another activity,
            // then go ahead and add the window.
            boolean willBeVisible = !a.mStartedActivity;
            if (!willBeVisible) {
                try {
                    willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(
                            a.getActivityToken());
                } catch (RemoteException e) {
                }
            }
            if (r.window == null && !a.mFinished && willBeVisible) {
                r.window = r.activity.getWindow();
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                l.softInputMode |= forwardBit;
                if (a.mVisibleFromClient) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }

            // If the window has already been added, but during resume
            // we started another activity, then don't yet make the
            // window visible.
            } else if (!willBeVisible) {
                if (localLOGV) Slog.v(
                    TAG, "launcher " + r + " mStartedActivity set");
                r.hideForNow = true;
            }

            // Get rid of anything left hanging around.
            cleanUpPendingRemoveWindows(r);

            // The window is now visible if it has been added, we are not
            // simply finishing, and we are not starting another activity.
            if (!r.activity.mFinished && willBeVisible
                    && r.activity.mDecor != null && !r.hideForNow) {
                if (r.newConfig != null) {
                    if (DEBUG_CONFIGURATION) Slog.v(TAG, "Resuming activity "
                            + r.activityInfo.name + " with newConfig " + r.newConfig);
                    performConfigurationChanged(r.activity, r.newConfig);
                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.newConfig));
                    r.newConfig = null;
                }
                if (localLOGV) Slog.v(TAG, "Resuming " + r + " with isForward="
                        + isForward);
                WindowManager.LayoutParams l = r.window.getAttributes();
                if ((l.softInputMode
                        & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)
                        != forwardBit) {
                    l.softInputMode = (l.softInputMode
                            & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))
                            | forwardBit;
                    if (r.activity.mVisibleFromClient) {
                        ViewManager wm = a.getWindowManager();
                        View decor = r.window.getDecorView();
                        wm.updateViewLayout(decor, l);
                    }
                }
                r.activity.mVisibleFromServer = true;
                mNumVisibleActivities++;
                if (r.activity.mVisibleFromClient) {
                    r.activity.makeVisible();
                }
            }

            if (!r.onlyLocalRequest) {
                r.nextIdle = mNewActivities;
                mNewActivities = r;
                if (localLOGV) Slog.v(
                    TAG, "Scheduling idle handler for " + r);
                Looper.myQueue().addIdleHandler(new Idler());
            }
            r.onlyLocalRequest = false;

            // Tell the activity manager we have resumed.
            if (reallyResume) {
                try {
                    //更新ActivityRecord里的相关信息
                    ActivityManagerNative.getDefault().activityResumed(token);
                } catch (RemoteException ex) {
                }
            }

        } else {
            // If an exception was thrown when trying to resume, then
            // just end this activity.
            try {
                ActivityManagerNative.getDefault()
                    .finishActivity(token, Activity.RESULT_CANCELED, null);
            } catch (RemoteException ex) {
            }
        }
    }
```


